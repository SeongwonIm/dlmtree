---
title: "Treed Distributed Lag Non-Linear Models"
author: "Daniel Mork, Colorado State University"
date: "8/3/2020"
output:
  html_document: 
    theme: lumen
    toc: yes
    toc_float: yes
---

## Introduction to TDLNM

In this vignette we demonstrate how to apply the `tdlnm` function found in the `dlmtree` package. TDLNM is a framework for estimating distributed lag non-linear models. This method operates using a set of regression trees that each assume piecewise constant relationships across the exposure-time space. TDLNM outperforms spline-based models when the exposure-time surface is not smooth and performs similarly in smooth settings. TDLNM also produces lower variance estimates while maintain high coverage and more precisely identifies critical windows within the exposure-time surface.

### Installation
To install package `dlmtree` first use the `devtools` package and run function `install_github`.
```{r, eval = FALSE}
library(devtools)
install_github("danielmork/dlmtree")
```

### Data
For this vignette we will use a data simulation available in the `dlmtree` package.
```{r}
library(dlmtree)
set.seed(1)
D <- tdlnm.sim(effect = "A", error.to.signal = 1) # try effects B, C, and D
```

## TDLNM
The first step to running TDLNM is defining splitting point across the range of exposure-concentration values. Then run the model for the desired number of iterations. We recommend using $20$ trees and $\geq15000$ iterations thinned to every tenth iteration following $\geq5000$ burn-in iterations. Model convergence can be checked by comparing the consitency or results across multiple runs.
### Run Model
```{r}
splits <- seq(min(D$exposure), max(D$exposure), length.out = 32)
res <- tdlnm(formula = y ~ ., 
             data = D$dat, 
             exposure.data = as.matrix(D$exposure),
             exposure.splits = list("type" = "values", "split.vals" = splits),
             n.trees = 20, n.burn = 2000, n.iter = 5000, n.thin = 10)
```

### Summary
Following the model run, summarize the results using the `summary` function.
```{r}
res_sum <- summary(res, cenval = D$cenval,
                   pred.at = seq(min(D$exposure), max(D$exposure), length.out = 100),
                   conf.level = 0.95)
res_sum
```

### Fixed Effects
```{r}
boxplot(res$gamma[,-1], xlab = "Parameters", ylab = "Effect") # Boxplot estimated effects
points(1:10, D$params, col = "red", pch = 16) # Red dots = truth
```

### Plots
#### Exposure-time surface
```{r}
plot(res_sum)
```

#### Slice at exposure-concentration = 3
```{r}
plot(res_sum, plot.type = "slice", val = 3, main = "Slice at concentration 3")
```

#### Slice at time = 13
```{r}
plot(res_sum, plot.type = "slice", time = 13, main = "Slice at time 13")
```

### Compare to truth
```{r}
truth <- D$dlnm.fun(sapply(1:37, function(i) res_sum$pred.at), D$cenval, F)
# RMSE
sqrt(mean((res_sum$matfit - truth)^2))
# Coverage
mean(res_sum$cilower < truth & res_sum$ciupper > truth)
# True positive effect classification
(length(which(res_sum$cilower > 0 & truth > 0)) + 
    length(which(res_sum$ciupper < 0 & truth < 0))) /
  length(which(truth != 0))
# False positive effect classification
(length(which(res_sum$cilower > 0 & truth == 0)) + 
    length(which(res_sum$ciupper < 0 & truth == 0))) /
  length(which(truth == 0))
```




## TDLNMse
In the second vignette we show an example of TDLNMse (with smoothing in exposure-concentration effect). The model setup is identical to TDLNM, but with an additional input--either a scalar smoothing value or a matrix of exposure-measurement standard errors.
```{r}
splits <- seq(min(D$exposure), max(D$exposure), length.out = 52)
res2 <- tdlnm(formula = y ~ ., 
              data = D$dat, 
              exposure.data = as.matrix(D$exposure),
              exposure.se = sd(D$exposure)/2, 
              exposure.splits = list("type" = "values", "split.vals" = splits),
              n.trees = 20, n.burn = 1000, n.iter = 5000, n.thin = 10)
```

### Summary
Following the model run, summarize the results using the `summary` function. Since you must select the exposure-response values at which to predict, the smoothing is set to be the average smoothing from the surface. You may also specify a different smoothing value if desired.
```{r}
res_sum2 <- summary(res2, cenval = D$cenval,
                    pred.at = seq(min(D$exposure), max(D$exposure), length.out = 100),
                    conf.level = 0.95)
res_sum2
```

### Fixed Effects
```{r}
boxplot(res2$gamma[,-1], xlab = "Parameters", ylab = "Effect") # Boxplot estimated effects
points(1:10, D$params, col = "red", pch = 16) # Red dots = truth
```

### Plots
#### Exposure-time surface
```{r}
plot(res_sum2)
```

#### Slice at exposure-concentration = 3
```{r}
plot(res_sum2, plot.type = "slice", val = 3, main = "Slice at concentration 3")
```

#### Slice at time = 13
```{r}
plot(res_sum2, plot.type = "slice", time = 13, main = "Slice at time 13")
```

### Compare to truth
```{r}
truth <- D$dlnm.fun(sapply(1:37, function(i) res_sum2$pred.at), D$cenval, F)
# RMSE
sqrt(mean((res_sum2$matfit - truth)^2))
# Coverage
mean(res_sum2$cilower < truth & res_sum2$ciupper > truth)
# True positive effect classification
(length(which(res_sum2$cilower > 0 & truth > 0)) + 
    length(which(res_sum2$ciupper < 0 & truth < 0))) /
  length(which(truth != 0))
# False positive effect classification
(length(which(res_sum2$cilower > 0 & truth == 0)) + 
    length(which(res_sum2$ciupper < 0 & truth == 0))) /
  length(which(truth == 0))
```
