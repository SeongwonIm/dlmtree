library(ggplot2)
library(tidyverse)
library(scales)
library(patchwork)
library(data.table)
library(gridExtra)
library(grid)
library(dlmtree)
# Create "notin" operator as it only works in filter() in tidyverse
`%notin%` <- Negate(`%in%`)


# dlmtree - HDLMM
set.seed(61123)
D <- sim.dlmtree(sim = "D", n = 4000)
fit <- dlmtree(y ~ ., data = D$dat, 
               exposure.data = D$exposure.dat, 
               mixture.interactions = "noself", 
               dlm.type = "hdlmm", 
               #step.prob.mod = c(0.05, 0.05, 0.85),
               step.prob.tdlm = c(0.3, 0.3, 0.3),
               effect.size = 1,
               n.burn = 1000, 
               n.iter = 2000, 
               n.thin = 2,
               n.trees = 10,
               diagnostics = T)


# Read RDS data if want to run diagnostics on data analysis with HPC
setwd("/Users/seongwonim/Google Drive/Ander/HDLMM/DataAnalysis_HDLM/RDS/Original/")
fit <- readRDS("hdlmm_pm25_ns_fit.RData")




#-------------------------------------------------------------
# Result processing
#-------------------------------------------------------------
DLM = fit$TreeStructs %>% 
  mutate(Tree = Tree + 1) %>% 
  mutate(Exposure = exp + 1)






#-------------------------------------------------------------
# Modifier / DLM trees size trace plots
#-------------------------------------------------------------
# Setup
colnames(fit$termNodesMod) <- colnames(fit$termNodesDLM1) <- colnames(fit$termNodesDLM2) <- paste0(1:fit$nTrees) # label trees
ModnTerm_df = fit$termNodesMod %>% as.data.frame() %>% mutate(iter = 1:nrow(fit$termNodesMod)) %>% pivot_longer(-iter)
DLM1nTerm_df = fit$termNodesDLM1 %>% as.data.frame() %>% mutate(iter = 1:nrow(fit$termNodesDLM1)) %>% pivot_longer(-iter)
DLM2nTerm_df = fit$termNodesDLM2 %>% as.data.frame() %>% mutate(iter = 1:nrow(fit$termNodesDLM2)) %>% pivot_longer(-iter)
colnames(ModnTerm_df) <- colnames(DLM1nTerm_df) <- colnames(DLM2nTerm_df) <- c("Iter", "Tree", "nTerm") # Long table column names

# Modifier tree
ggplot(ModnTerm_df, aes(x = Iter, y = nTerm)) + 
  geom_line(col = "coral2", linewidth = 0.2) +
  theme_bw() +
  scale_y_continuous(breaks= pretty_breaks()) +
  facet_wrap(~Tree) +
  labs(title = "Modifier tree terminal node # traceplots", x = "MCMC iteration", y = "Terminal node #")

# DLM tree 1
ggplot(DLM1nTerm_df, aes(x = Iter, y = nTerm)) + 
  geom_line(col = "aquamarine3", linewidth = 0.2) +
  theme_bw() +
  scale_y_continuous(breaks= pretty_breaks()) +
  facet_wrap(~Tree) +
  labs(title = "DLM tree 1 terminal node # traceplots", x = "MCMC iteration", y = "Terminal node #")

# DLM tree 2
ggplot(DLM2nTerm_df, aes(x = Iter, y = nTerm)) + 
  geom_line(col = "aquamarine3", linewidth = 0.2) +
  theme_bw() +
  scale_y_continuous(breaks= pretty_breaks()) +
  facet_wrap(~Tree) +
  labs(title = "DLM tree 2 terminal node # traceplots", x = "MCMC iteration", y = "Terminal node #")

# Modifier tree size
table(fit$TreeStructs$Mod)

# Tree size boxplots (900 x 600)
# Modifier
colMeans(fit$termNodesMod)
ggplot(ModnTerm_df, aes(x = Tree, y = nTerm)) + 
  geom_boxplot() + 
  theme_bw() +
  labs(title = "Modifier tree terminal node #", x = "Tree", y = "Terminal node #") 

# Tree 1
colMeans(fit$termNodesDLM1)
ggplot(DLM1nTerm_df, aes(x = Tree, y = nTerm)) + 
  geom_boxplot() + 
  theme_bw() +
  labs(title = "DLM tree 1 terminal node #", x = "Tree", y = "Terminal node #") 

# Tree 2
colMeans(fit$termNodesDLM2)
ggplot(DLM2nTerm_df, aes(x = Tree, y = nTerm)) + 
  geom_boxplot() + 
  theme_bw() +
  labs(title = "DLM tree 2 terminal node #", x = "Tree", y = "Terminal node #")







#-------------------------------------------------------------
# Posterior inclusion probability plot
#-------------------------------------------------------------
pip_df = data.frame(Modifier = names(pip(fit)), PIP = pip(fit))
pip_gg <- ggplot(pip_df, aes(x = Modifier, y = PIP)) + 
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip()+
  labs(title = "Posterior inclusion probability of modifiers") + 
  theme_bw()
pip_gg










# #-------------------------------------------------------------
# # Posterior inclusion probability bootstrap (1200 x 800)
# #-------------------------------------------------------------
# setwd("/Users/seongwonim/Google Drive/Ander/HDLMM/DataAnalysis_HDLM/CSV/")
# pip_50k <- read.csv("pip_100k.csv", header = F)
# colnames(pip_50k) <- c("MatAge", "MotherBMI", "Income", "MEduc", "MotherHeightIn", "PriorWeight", 
#                        "Sex", "Marital2", "PrenatalCare", "Smk", "race", "hispanic")
# pip_50k %>% 
#   pivot_longer(cols = c("MatAge", "MotherBMI", "Income", "MEduc", "MotherHeightIn", "PriorWeight", 
#                         "Sex", "Marital2", "PrenatalCare", "Smk", "race", "hispanic"), 
#                names_to = "Modifier", values_to = "PIP") %>% 
#   # ggplot(aes(x = forcats::fct_reorder(factor(Modifier), PIP, mean, .desc = T), y = PIP, fill = Modifier)) +
#   ggplot(aes(x = Modifier, y = PIP, fill = Modifier)) +
#   geom_boxplot(alpha=0.7) +
#   stat_summary(fun=mean, geom="point", size=4, color="coral") + 
#   theme_bw(base_size = 16) + 
#   labs(x = "Modifier", y = "PIP", title = "PIP Bootstrap: 50 sets of 100k samples") + 
#   theme(legend.position = "none")











#-------------------------------------------------------------
# Exposure count traceplot
#-------------------------------------------------------------
expCount_df = fit$expCount
colnames(expCount_df) <- paste0("e", 1:fit$nExp)
expCount_df = melt(expCount_df)
colnames(expCount_df) <- c("Iter", "Exposure", "Count")
ggplot(expCount_df, aes(x = Iter, y = Count, col = Exposure)) + 
  geom_line() +
  theme_bw() + 
  scale_y_continuous(breaks= pretty_breaks()) +
  labs(title = "Exposure selection traceplot", x = "MCMC iteration", y = "Number of trees assigned")







#-------------------------------------------------------------
# Modifier selection MCMC analysis 
#-------------------------------------------------------------
modCount_df = as.data.frame(fit$modCount)
modCount_iter = nrow(modCount_df)

modCount_df = melt(modCount_df)
colnames(modCount_df) = c("Modifier", "Count")
modCount_df$iter = rep(1:modCount_iter, length(fit$modNames))
ggplot(modCount_df, aes(x = iter, y = Count, col = Modifier)) + 
  geom_line()+ 
  facet_wrap(~Modifier) + 
  theme_bw()+
  labs(title = "Modifier selection diagnostic", x = "MCMC iteration", y = "Number of trees with modifiers") + 
  theme(legend.position = "none")










#---------------------------------------------------------------------------------
# Main effects for exposure 1 for six different combinations of modifiers 
#---------------------------------------------------------------------------------
mod_df = data.frame("mod_num" = rep(seq(-5, 5, 2), 2), 
                    "mod_bin" = c(rep(0, 6), rep(1, 6)), 
                    "mod_scale" = rep(0.5, 12))

mod = cbind(mod_df, D$dat[1:12, 4:13])
n = nrow(mod)

# Build 'draws' list for exposure
exposure = 2
draws <- lapply(1:fit$mcmcIter, function(i) matrix(0.0, n, fit$pExp))

# Iterate through DLM matrix and add to draws
for(i in 1:nrow(DLM)){
  # Check if it is the selected exposure
  if(DLM$exp[i] != exposure){
    next
  }
  
  # Extract mcmc iteration count and the rule
  Iter <- DLM$Iter[i]
  Rule <- DLM$Rule[i]
  if (Rule == ""){
    idx <- 1:n
  } else {
    idx <- which(eval(parse(text = Rule)))
  }
  
  t <- DLM$tmin[i]:DLM$tmax[i]
  est <- DLM$est[i]
  draws[[Iter]][idx, t] <- draws[[Iter]][idx, t] + est
}

# posterior mcmc calculation
draws <- array(do.call(c, draws), c(n, fit$pExp, fit$mcmcIter))

# Exposure effect plot
dlmest <- sapply(1:(fit$pExp), function(t) {rowMeans(draws[, t, , drop=F])}) # All of n / t = 1 / all mcmc
dlmest.lower <- sapply(1:(fit$pExp), function(t) {apply(draws[, t, , drop=F], 1, quantile, probs = (1 - 0.95)/2)})
dlmest.upper <- sapply(1:(fit$pExp), function(t) {apply(draws[, t, , drop=F], 1, quantile, probs = 1 - (1 - 0.95)/2)})

# Prepare a data.frame for plotting
Lags = 1:37
dlmest_df = cbind.data.frame(mod_df, dlmest)
dlmest.lwr_df = cbind.data.frame(mod_df, dlmest.lower)
dlmest.upr_df = cbind.data.frame(mod_df, dlmest.upper)

dlmest_df_wide <- dlmest_df %>% 
  pivot_longer(cols = -c("mod_num", "mod_bin", "mod_scale"),
               names_to = "Lags",
               values_to = "Effect")
dlmest.lwr_df_wide <- dlmest.lwr_df %>% 
  pivot_longer(cols = -c("mod_num", "mod_bin", "mod_scale"),
               names_to = "Lags",
               values_to = "Effect")
dlmest.upr_df_wide <- dlmest.upr_df %>% 
  pivot_longer(cols = -c("mod_num", "mod_bin", "mod_scale"),
               names_to = "Lags",
               values_to = "Effect")

# Combine three data frames
dlmest_df_wide$lwr = dlmest.lwr_df_wide$Effect
dlmest_df_wide$upr = dlmest.upr_df_wide$Effect
dlmest_df_wide$Lags <- as.integer(dlmest_df_wide$Lags)
dlmest_df_wide$mod_num <- as.factor(dlmest_df_wide$mod_num)
dlmest_df_wide$mod_bin <- as.factor(dlmest_df_wide$mod_bin)

# Plot
ggplot(dlmest_df_wide, aes(x = Lags, y = Effect)) +
  geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr),
              linetype = "dotted", color = "red", alpha = 0.1, fill = "gray") +
  theme_bw(base_size = 16) + 
  labs(title = paste0("Main effects of Exposure ", exposure," for 12 cases"), 
       x = "Time", y = "Exposure effect") + 
  facet_grid(mod_bin ~ mod_num, labeller = label_both)














#-------------------------------------------------------------
# Split points of continuous variable with histograms
#-------------------------------------------------------------
# modifier data for histogram
modhist_df <- fit$data %>% 
  select(fit$modNames) %>% 
  select_if(function(x) any(is.numeric(x))) # Select continuous variables only

# multiple plots
for(col in 1:ncol(modhist_df)){
  # Name
  modifier = colnames(modhist_df)[col]
  modifier_df = modhist_df[, col]
  colnames(modifier_df) = "Variable"
  
  # Split points
  lines <- splitpoints(fit, modifier, round = 2)
  
  # histogram with lines
  p <- ggplot(modifier_df, aes(x = Variable)) + 
    theme_bw() +
    geom_histogram(bins = 30) + 
    labs(title = modifier, x = "", y = "") + 
    geom_vline(xintercept = lines$location, 
               linetype = "dashed", col = "cyan")
  
  # Assign
  assign(paste0("p", col), p)
}

p1 + p2 + p3 + p4








# ------------------------------------------------------------------------------
# MCMC convergence plot of the result: DLM function & Each lag
# ------------------------------------------------------------------------------
# Set up a single observation
mod_df = data.frame("mod_num" = 3, "mod_bin" = 1, "mod_scale" = 0.5)
mod = cbind(mod_df, D$dat[1, 4:13])
n = nrow(mod)

# Build 'draws' list for exposure
exposure = 1
draws <- lapply(1:fit$mcmcIter, function(i) matrix(0.0, n, fit$pExp))

# Iterate through DLM matrix and add to draws
for(i in 1:nrow(DLM)){
  # Check if it is the selected exposure
  if(DLM$Exposure[i] != exposure){
    next
  }
  
  # Extract mcmc iteration count and the rule
  Iter <- DLM$Iter[i]
  Rule <- DLM$Rule[i]
  if (Rule == ""){
    idx <- 1:n
  } else {
    idx <- which(eval(parse(text = Rule)))
  }
  
  t <- DLM$tmin[i]:DLM$tmax[i]
  est <- DLM$est[i]
  draws[[Iter]][idx, t] <- draws[[Iter]][idx, t] + est
}

# posterior mcmc calculation
Mean_draws <- array(do.call(c, draws), c(n, fit$pExp, fit$mcmcIter))

# Exposure effect plot
dlmest <- sapply(1:(fit$pExp), function(t) {rowMeans(Mean_draws[, t, , drop=F])}) # All of n / t = 1 / all mcmc
dlmest_df <- data.frame(variable = 1:fit$pExp, value = dlmest)

# Reorganize as a matrix and add columns for plotting
MCMC_mtx <- matrix(NA, nrow = length(draws), ncol = fit$pExp)
for(iter in 1:length(draws)){
  MCMC_mtx[iter, 1:fit$pExp] <- draws[[iter]]
}
MCMC_df <- MCMC_mtx %>% as.data.frame()
colnames(MCMC_df) <- 1:fit$pExp
jump = 100 # Plot every 100th effect
MCMC_df <- MCMC_df[seq(1, fit$mcmcIter, jump), ]

MCMC_df <- melt(MCMC_df)
MCMC_df$iter = rep(seq(1, fit$mcmcIter, jump), fit$pExp)

# DLM function plot
MCMC_p <- ggplot(MCMC_df, aes(x = variable, y = value, group = iter)) + 
  geom_line(col = "gray") + 
  geom_line(data = dlmest_df, aes(x = variable, y = value), col = "red")+
  theme_bw() + 
  labs(y = "Effect", x = "Lag", title = paste0("MCMC iteration of estimated DLM function for every ", jump, " iteration"))

MCMC_p


# Each lag convergence diagnostic
MCMC_df <- MCMC_mtx %>% as.data.frame()
colnames(MCMC_df) <- paste0("Lag", 1:fit$pExp)
MCMC_df <- melt(MCMC_df)
MCMC_df$iter = rep(1:fit$mcmcIter, fit$pExp)

lag_p <- ggplot(MCMC_df, aes(x = iter, y = value)) + 
  geom_line() +
  theme_bw() + 
  labs(y = "Effect", x = "MCMC iteration", title = "MCMC iteration of each lag's effect") + 
  facet_wrap(~variable)

lag_p









# 
# # ------------------------------------------------------------------------------
# # Ensemble analysis: Proportion of effect from each tree
# # ------------------------------------------------------------------------------
# # Set up a single observation
# mod_df = data.frame("mod_num" = 3, "mod_bin" = 1, "mod_scale" = 0.5)
# mod = cbind(mod_df, D$dat[1, 4:13])
# n = nrow(mod)
# 
# 
# # Build 'draws' list for exposure
# exposure = 1
# draws <- lapply(1:fit$mcmcIter, function(i) matrix(0.0, fit$nTrees, fit$pExp))
# 
# # Iterate through DLM matrix and add to draws
# for(i in 1:nrow(DLM)){
#   if(i %% 10000 == 0){
#     print(i)
#   }
#   
#   
#   for(tree in 1:fit$nTrees){
#     # Check if it is the selected exposure
#     if(DLM$Exposure[i] != exposure || DLM$Tree != tree){
#       next
#     }
#     
#     # Extract mcmc iteration count and the rule
#     Iter <- DLM$Iter[i]
#     Rule <- DLM$Rule[i]
#     if (Rule == ""){
#       idx <- tree
#     } else {
#       idx <- which(eval(parse(text = Rule)))
#       if(length(idx) != 0){
#         idx <- tree
#       }
#     }
#     
#     t <- DLM$tmin[i]:DLM$tmax[i]
#     est <- DLM$est[i]
#     draws[[Iter]][idx, t] <- draws[[Iter]][idx, t] + est
#   }
# }









# setwd("/Users/seongwonim/Downloads/")
# fit <- readRDS("hdlmm_pm25_ns_t100b3.RData")

# ------------------------------------------------------------------------------
# Diagnostics: Must set diagnostic parameter to TRUE 
# Tree MH-Ratio analysis: Tree step & transition
# ------------------------------------------------------------------------------
modtree_df = as.data.frame(fit$treeDLMAccept[which(fit$treeDLMAccept[, 3] == 0), ])
dlmtree1_df = as.data.frame(fit$treeDLMAccept[which(fit$treeDLMAccept[, 3] == 1), ])
dlmtree2_df = as.data.frame(fit$treeDLMAccept[which(fit$treeDLMAccept[, 3] == 2), ])

colnames(modtree_df) <- colnames(dlmtree1_df) <- colnames(dlmtree2_df) <-
  c("Iter", "Tree", "Type", "Step", "Success", "exp", "count", "stepMHR", "Ratio")

# Data cleaning for success and steps
modtree_df <- modtree_df %>% mutate(Proposal = ifelse(Success == 2, "Accepted", "Rejected"))
dlmtree1_df <- dlmtree1_df %>% mutate(Proposal = ifelse(Success == 2, "Accepted", "Rejected"))
dlmtree2_df <- dlmtree2_df %>% mutate(Proposal = ifelse(Success == 2, "Accepted", "Rejected"))

levels(modtree_df$Proposal) <- levels(dlmtree1_df$Proposal) <- levels(dlmtree2_df$Proposal) <- c("Accepted", "Rejected")
modtree_df$Step <- as.factor(modtree_df$Step)
dlmtree1_df$Step <- as.factor(dlmtree1_df$Step)
dlmtree2_df$Step <- as.factor(dlmtree2_df$Step)
levels(modtree_df$Step) <- levels(dlmtree1_df$Step) <- levels(dlmtree2_df$Step) <- c("Grow", "Prune", "Change", "Swap")







# ------------------------------------------------------------------------------
# Accept / Reject per Step 
# ------------------------------------------------------------------------------
# Modifier tree
mod_accept <- modtree_df %>% 
              select(Step, Proposal) %>% 
              ggplot(aes(x = Step, fill = Proposal)) + 
                geom_bar() +
                theme_bw(base_size = 16) + 
                labs(x = "Transition step", y = "Count", title = "Modifier tree MH update") +
                scale_fill_manual(values = c("coral2", "gray"))

# Success per Step : DLM tree 1
dlm1_accept <- dlmtree1_df %>% 
              select(Step, Proposal) %>% 
                ggplot(aes(x = Step, fill = Proposal)) + 
                geom_bar() +
                theme_bw(base_size = 16) + 
                labs(x = "Transition step", y = "Count", title = "DLM tree 1 MH update")+
                scale_fill_manual(values = c("aquamarine3", "gray"))

# Success per Step : DLM tree 2
dlm2_accept <- dlmtree2_df %>% 
              select(Step, Proposal) %>% 
                ggplot(aes(x = Step, fill = Proposal)) + 
                geom_bar() +
                theme_bw(base_size = 16) + 
                labs(x = "Transition step", y = "Count", title = "DLM tree 2 MH update")+
                scale_fill_manual(values = c("aquamarine3", "gray"))

# 1800x1200
mod_accept + dlm1_accept + dlm2_accept + plot_annotation(title = "Tree update: Simulation: 1k / 2k / 2, Tree size = 20")





# ------------------------------------------------------------------------------
# Acceptance ratio (step + transition)
# ------------------------------------------------------------------------------
# Modifier
modtree_stepMHR = modtree_df %>% select(Iter, Tree, stepMHR, Ratio) %>% mutate(MHR = stepMHR + Ratio)
mod_MHR <- ggplot(modtree_stepMHR, aes(x = Iter, y = MHR)) + 
  geom_line(col = "coral2", size = 0.1) +
  theme_bw() +
  scale_y_continuous(breaks= pretty_breaks()) +
  facet_wrap(~Tree) +
  labs(title = "Modifier tree MH Ratio", x = "MCMC iteration", y = "MH Ratio")

# DLM tree 1
dlmtree1_stepMHR = dlmtree1_df %>% select(Iter, Tree, stepMHR, Ratio) %>% mutate(MHR = stepMHR + Ratio)
dlm1_MHR <- ggplot(dlmtree1_stepMHR, aes(x = Iter, y = MHR)) + 
  geom_line(col = "aquamarine3", size = 0.1) +
  theme_bw() +
  scale_y_continuous(breaks= pretty_breaks()) +
  facet_wrap(~Tree) +
  labs(title = "DLM tree 1 MH Ratio", x = "MCMC iteration", y = "MH Ratio")

# DLM tree 2
dlmtree2_stepMHR = dlmtree2_df %>% select(Iter, Tree, stepMHR, Ratio) %>% mutate(MHR = stepMHR + Ratio) 
dlm2_MHR <- ggplot(dlmtree2_stepMHR, aes(x = Iter, y = MHR)) + 
  geom_line(col = "aquamarine3", size = 0.1) +
  theme_bw() +
  scale_y_continuous(breaks= pretty_breaks()) +
  facet_wrap(~Tree) +
  labs(title = "TDLM tree 2 MH Ratio", x = "MCMC iteration", y = "MH Ratio")

mod_MHR + dlm1_MHR + dlm2_MHR + plot_annotation(title = "MH Ratio: Simulation: 2.5k / 10k / 2")





# ------------------------------------------------------------------------------
# Hyperparameters traceplots
# ------------------------------------------------------------------------------
# nu
plot(1:length(fit$nu), fit$nu, type = "l", 
     main = expression(paste(nu, " traceplot")), 
     ylab = expression(paste(nu)), xlab = "Iteration")
abline(h = mean(fit$nu), col = "red", lty = 2)
hist(fit$nu, breaks = 30, main = "nu")

# sigma2
plot(1:length(fit$sigma2), fit$sigma2, type = "l", 
     main = expression(paste(sigma, " traceplot")), 
     ylab = expression(paste(sigma)), xlab = "Iteration")
abline(h = mean(fit$sigma2), col = "red", lty = 2)
hist(fit$sigma2, breaks = 30, main = "sigma2")

# Exposure specific variance (shrinkage)
# e1:mu
plot(1:length(fit$muExp[, 1]), fit$muExp[, 1], type = "l", 
     main = "Exposure 1 - specific variance",
     ylab = expression(paste("Exposure 1: ", mu)),
     xlab = "Iteration")
abline(h = mean(fit$muExp[, 1]), col = "red", lty = 2)
hist(fit$muExp[, 1], breaks = 30, main = "mu: e1")

# e2:mu
plot(1:length(fit$muExp[, 2]), fit$muExp[, 2], type = "l", 
     main = "Exposure 2 - specific variance",
     ylab = expression(paste("Exposure 2:", mu)),
     xlab = "Iteration")
abline(h = mean(fit$muExp[, 1]), col = "red", lty = 2)
hist(fit$muExp[, 2], breaks = 30, main = "mu: e2")

# e3:mu
plot(1:length(fit$muExp[, 3]), fit$muExp[, 3], type = "l", 
     main = "Exposure 3 - specific variance",
     ylab = expression(paste("Exposure 3:", mu)),
     xlab = "Iteration")
abline(h = mean(fit$muExp[, 3]), col = "red", lty = 2)
hist(fit$muExp[, 3], breaks = 30, main = "mu: e3")












# ------------------------------------------------------------------------------
# Mixture / Interaction diagnostics 
# ------------------------------------------------------------------------------
MIX = fit$MIX
MIX_list = list()

mod_df = data.frame("mod_num" = rep(seq(-5, 5, 2), 2), 
                    "mod_bin" = c(rep(0, 6), rep(1, 6)), 
                    "mod_scale" = rep(0.5, 12))

which_interaction = 1

for(mod_idx in 1:nrow(mod_df)){
  mod = mod_df[mod_idx, ]
  n = nrow(mod)
  
  for (i in sort(unique(MIX$exp1))) {
    for (j in sort(unique(MIX$exp2))) {
      draws <- lapply(1:fit$mcmcIter, function(i) matrix(0, fit$pExp, fit$pExp))
      
      if(i == j){
        next
      }
      
      # Subsetting matrix with exposure combination
      newMIX = MIX[which(MIX$exp1 == i & MIX$exp2 == j), ]
      
      # First Subset with rules
      for(row in 1:nrow(newMIX)){
        Iter <- newMIX$Iter[row]
        Rule <- newMIX$Rule[row]
        if (Rule == ""){
          idx <- 1:n
        } else {
          idx <- which(eval(parse(text = Rule)))
          if(length(idx) == 0){ # avoid integer(0) problem
            idx = 0
          }
        }
        
        if(idx == 1){
          t1range <- newMIX$tmin1[row]:newMIX$tmax1[row]
          t2range <- newMIX$tmin2[row]:newMIX$tmax2[row]
          est <- newMIX$est[row]
          
          for(t1 in t1range){
            for(t2 in t2range){
              draws[[Iter]][t1, t2] <- draws[[Iter]][t1, t2] + est
            }
          }
        }
      }
      
      mixname <- paste0(fit$expNames[i + 1], "-", fit$expNames[j + 1])
      MIX_list[[mixname]] <- draws
    }
  }
  
  MIX_list_sum <- list()
  for(ee in 1:length(MIX_list)){
    MIX_ee = MIX_list[[ee]]
    
    # Average of matrices
    mixEst <- Reduce("+", MIX_ee)/length(MIX_ee)
    
    MIX_list_sum[[names(MIX_list)[ee]]] <- mixEst
  }
  
  plotDat <- data.frame(x = rep(1:fit$pExp, fit$pExp),
                        y = rep(1:fit$pExp, each = fit$pExp))
  
  plotDat <- cbind.data.frame(plotDat,
                              Effect = c(MIX_list_sum[[which_interaction]]))
  
  xName = substring(names(MIX_list_sum)[which_interaction], 1, 2)
  yName = substring(names(MIX_list_sum)[which_interaction], 4, 5)
  
  p <- ggplot(plotDat, aes(x = `x`, y = `y`, z = `Effect`, fill = `Effect`)) +
    geom_tile() +
    scale_fill_viridis_c() +
    labs(x = xName, y = yName, title = paste0("num: ", mod$mod_num, 
                                              ", bin: ", mod$mod_bin))
  
  assign(paste0("mix", mod_idx), p)
}

grid.arrange(mix1, mix2, mix3, mix4, mix5, mix6, 
             mix7, mix8, mix9, mix10, mix11, mix12, nrow = 2,
             top = textGrob(paste0(names(MIX_list)[which_interaction], 
                                   " interaction effect for each modifier combination")))













# ------------------------------------------------------------------------------
# DLM plots for three modifiers 
# ------------------------------------------------------------------------------
# Choose two categorical modifiers & one continuous modifier
fit$modNames
mod1 <- "mod_bin"
mod2 <- "b1"
mod_c <- "mod_num"

# Create an empty list with modifier combinations for plotting
plot_list <- list(mod1 = pull(unique(fit$data[mod1])),
                  mod2 = pull(unique(fit$data[mod2])))

plot_df <- do.call(expand.grid, plot_list)
colnames(plot_df) <- c(mod1, mod2)


# Randomly sample 100 from data
sub_n = 4

sample_df <- fit$data %>% 
    sample_n(., sub_n * nrow(plot_df)) %>% 
    select(-y, -all_of(mod1), -all_of(mod2)) %>% # remove the subsetting modifier 
    mutate(ID = 1:(sub_n * nrow(plot_df)))

sample_df[, mod1] = rep(plot_df[, 1], sub_n)
sample_df[, mod2] = rep(plot_df[, 2], sub_n)


# DLM calculation
mod = sample_df
n = nrow(mod)

# Build 'draws' list for exposure
exposure = 1
draws <- lapply(1:fit$mcmcIter, function(i) matrix(0.0, n, fit$pExp))

# Iterate through DLM matrix and add to draws
for(i in 1:nrow(DLM)){
  # Check if it is the selected exposure
  if(DLM$Exposure[i] != exposure){
    next
  }
  
  # Extract mcmc iteration count and the rule
  Iter <- DLM$Iter[i]
  Rule <- DLM$Rule[i]
  if (Rule == ""){
    idx <- 1:n
  } else {
    idx <- which(eval(parse(text = Rule)))
  }
  
  t <- DLM$tmin[i]:DLM$tmax[i]
  est <- DLM$est[i]
  draws[[Iter]][idx, t] <- draws[[Iter]][idx, t] + est
}

# posterior mcmc calculation
draws <- array(do.call(c, draws), c(n, fit$pExp, fit$mcmcIter))

# Exposure effect plot
dlmest <- sapply(1:(fit$pExp), function(t) {rowMeans(draws[, t, , drop=F])}) # All of n / t = 1 / all mcmc
colnames(dlmest) <- 1:fit$pExp

# Combine the modifier df and the DLM effect --> convert to a long form
modifier_df = sample_df %>% select(mod1, mod2, mod_num, ID) # ######### CHANGE mod_num
p <- cbind(modifier_df, dlmest) %>% 
  pivot_longer(cols = -c(mod1, mod2, mod_num, ID), names_to = "Lag", values_to = "Effect") %>%
  mutate(Lag = as.numeric(Lag)) %>% 
  ggplot(aes(x = Lag, y = Effect, col = mod_num, group = ID)) + 
  geom_line(size = 0.3) + 
  theme_bw(base_size = 16) + 
  labs(title = "", x = "Time (Lag)", y = "Exposure effect") + 
  facet_grid(mod_bin ~ b1, labeller = label_both) + 
  scale_color_gradient(low = "#AF7AC5", high = "#E74C3C") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
p






dlm

